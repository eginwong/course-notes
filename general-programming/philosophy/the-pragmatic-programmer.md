# The Pragmatic Programmer

1. Care about your craft
2. Think about your work
3. Provide options, not lame execuses
4. Don't live with broken windows
5. Be a catalyst for change
6. Remember the big picture
7. Make quality a requirements issue
8. Invest regularly in your knowledge portfolio (keep on learning, and different stuff at that!)
9. Think critically about what you read and hear
10. It's both what you say and the way you say it
11. DRY
12. Make it easy to reuse
13. Eliminate effects between unrelated things (side effects)
14. There are no final decisions (make things easily reversible and flexible)
15. Use Tracer bullets to find the target (write non-throwaway code and align after e2e is made)
16. Prototype to learn
17. Program close to the problem domain
18. Estimate to avoid surprises
19. Iterate the schedule with the code
20. Keep knowledge in plain text
21. Use the power of command shells
22. Use a single editor well
23. Always use source code control
24. Fix the problem, not the blame
25. **Don't panic**
26. "select" isn't broken, likely not the system
27. Don't assume it, prove it
28. Learn a text manipulation language
29. Write code that writes code
30. You can't write perfect software
31. Design with Contracts (to strictly enforce behaviour and to promise as little as possible, pre/post-conditions)
32. Crash early
33. If it can't happen, use assertions to ensure that it won't (minor performance impact worth it, unless case-by-case)
34. Use Exceptions for exceptional problems (immediate nonlocal transfer of control, code should be able to run without exception logic)
35. Finish what you start (open in same order, close in reverse order)
36. Minimize Coupling Between Modules (if creates and owns objects, can call its elements)
37. Configure, Don't integrate (metadata)
38. Put abstractions in code, details in metadata
39. Analyze workflow to improve concurrency
40. Design using services (well-defined, independent, concurrent with interfaces)
41. Always design for concurrency
42. Separate Views from Models
43. Use blackboards to coordinate workflow
44. Don't program by coincidence
45. Estimate the order of your algorithms
46. Test your estimates
47. Refactor early, refactor often
48. Design to Test
49. Test your software or your users will
50. Don't use wizard code you don't understand
51. Don't gather requirements, dig for them
52. Work with a user to think like a user
53. Abstractions live longer than details
54. Use a project glossary
55. Don't think outside the box, find the box
56. Listen to nagging doubts, start when you're ready
57. Some things are better done than described
58. Don't be a slave to formal methods
59. Expensive Tools do not produce better designs
60. Organize around functionality, not job functions
61. Don't use manual procedures
62. Test early, often, automatically
63. Coding ain't done 'til all the tests run
64. Use saboteurs to test your testing
65. Test state coverage, not code coverage
66. Find bugs once
67. Treat English as just another programming language
68. Build documentation in, don't bolt it on
69. Gently exceed your users' expectations
70. Sign your work    


## A Pragmatic Philosophy
- aware of the big picture
- responsible
    * commitment to doing something right
    * when we make mistakes/errors, admit them honestly and offer options
    * must plan out risks ahead of time and prepare contingencies
    * rubber duck talking to your boss about the problem and try to think about what next steps they would provide
- fix small and big problems immediately or mitigate them to avoid future rot
- trick people into assisting with helpful efforts if necessary
- get things working good enough, acceptable enough and signed off by users and move on
- think about exactly what message you want to get across
    * know your audience
    * choose your timing
    * listen
    * make your content look good
    * communicate and get back to people

## A Pragmatic Approach
- orthogonality makes things easier to test, reason about, and update
- for #17, look into BNF or metaprogramming
- for #18, beware the unit of estimation, as that will anchor people in its fluctuation
  * use models to reduce ambiguity 
  * record your estimates to get better and identify what went wrong
